<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Temple Tile Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .tooltip {
      position: absolute;
      background: #18181b;
      border: 1px solid #3f3f46;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 50;
      pointer-events: none;
      white-space: nowrap;
    }
    .floor-tile {
      background-color: #372f21;
      box-shadow: inset 0 0 0 2px #98854d;
    }
    .faded {
      opacity: 0.6;
      filter: saturate(0.7);
    }
  </style>
</head>
<body class="bg-zinc-900 text-zinc-100">
<div id="app" class="p-6"></div>

<script>
// Initial setup
const GRID_SIZE = 9;
let selectedTile = null;
let planningMode = false;
let bonusFilter = "";
let grid = Array(GRID_SIZE * GRID_SIZE).fill(null);

// Room names for display
const ROOM_NAMES = {
  Spymaster: "Spymaster",
  Garrison: "Garrison",
  LegionBarrack: "Legion Barracks",
  Commander: "Commander",
  FleshSurgeon: "Flesh Surgeon",
  Smithy: "Smithy",
  Armoury: "Armoury",
  SynthfleshLab: "Synthflesh Lab",
  TranscendentBarracks: "Transcendent Barracks",
  GolemWorks: "Golem Works",
  AlchemyLab: "Alchemy Lab",
  Thaumaturge: "Thaumaturge",
  CorruptionChamber: "Corruption Chamber",
  Generator: "Generator",
  SacrificialChamber: "Sacrificial Chamber",
  SealedVault: "Sealed Vault"
};

// Room icons for visual representation
const ROOM_ICONS = {
  AlchemyLab: "icons/IconAlchemyLab.webp",
  Armoury: "icons/IconArmoury.webp",
  Commander: "icons/IconCommander.webp",
  CorruptionChamber: "icons/IconCorruption.webp",
  FleshSurgeon: "icons/IconFleshSurgeon.webp",
  Garrison: "icons/IconGarrison.webp",
  Generator: "icons/IconGenerator.webp",
  GolemWorks: "icons/IconGolemWorks.webp",
  SacrificialChamber: "icons/IconSacrificialChamber.webp",
  Smithy: "icons/IconSmithy.webp",
  SynthfleshLab: "icons/IconSynthflesh.webp",
  Thaumaturge: "icons/IconThaumaturge.webp",
  TranscendentBarracks: "icons/IconTranscendentBarracks.webp",
  SealedVault: "icons/IconVault.webp",
  LegionBarrack: "icons/IconViperLegionBarracks.webp",
  Spymaster: "icons/IconViperSpymaster.webp"
};

// Room connection rules (simplified)
const ROOM_CONNECTION_RULES = {
  Spymaster: { canConnectTo: ["Garrison"] },
  Garrison: { canConnectTo: ["Spymaster", "Commander", "SynthfleshLab", "Armoury"] },
  Commander: { canConnectTo: ["Garrison", "TranscendentBarracks"] },
  TranscendentBarracks: { canConnectTo: ["Commander", "SynthfleshLab"] },
  SynthfleshLab: { canConnectTo: ["Garrison", "FleshSurgeon", "TranscendentBarracks"] },
  FleshSurgeon: { canConnectTo: ["SynthfleshLab"] },
  LegionBarrack: { canConnectTo: ["Spymaster", "Garrison", "Armoury"] },
  Armoury: { canConnectTo: ["Garrison", "LegionBarrack", "Smithy", "AlchemyLab"] },
  Smithy: { canConnectTo: ["Armoury", "GolemWorks"] },
  GolemWorks: { canConnectTo: ["Smithy"] },
  AlchemyLab: { canConnectTo: ["Armoury", "Thaumaturge"] },
  Thaumaturge: { canConnectTo: ["AlchemyLab", "CorruptionChamber", "SacrificialChamber", "Generator"] },
  CorruptionChamber: { canConnectTo: ["Thaumaturge", "SacrificialChamber"] },
  SacrificialChamber: { canConnectTo: ["Generator", "Thaumaturge", "CorruptionChamber"] },
  Generator: { canConnectTo: ["Thaumaturge", "SacrificialChamber"] }
};

// Function to check if placement is valid
function isValidPlacement(tileIndex, tileName) {
  const currentTile = grid[tileIndex];

  // Ensure the placement follows connection rules
  if (currentTile) {
    const neighbors = getNeighbors(tileIndex);
    const invalidConnection = neighbors.some(neighbor => {
      const neighborTile = grid[neighbor]?.tile;
      return neighborTile && !ROOM_CONNECTION_RULES[tileName]?.canConnectTo.includes(neighborTile);
    });

    return !invalidConnection;
  }

  return true;
}

// Get neighboring tile indices (up, down, left, right)
function getNeighbors(index) {
  const neighbors = [];
  const row = Math.floor(index / GRID_SIZE);
  const col = index % GRID_SIZE;

  if (row > 0) neighbors.push(index - GRID_SIZE); // Up
  if (row < GRID_SIZE - 1) neighbors.push(index + GRID_SIZE); // Down
  if (col > 0) neighbors.push(index - 1); // Left
  if (col < GRID_SIZE - 1) neighbors.push(index + 1); // Right

  return neighbors;
}

// Function to render the grid
function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const container = document.createElement("div");
  container.className = "flex gap-6 items-start";

  /* ---------- GRID COLUMN ---------- */
  const gridCol = document.createElement("div");
  gridCol.className = "space-y-3 shrink-0";

  const gridEl = document.createElement("div");
  gridEl.className = "grid grid-cols-9 gap-1";

  grid.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.className = "w-12 h-12 rounded-lg p-1 bg-zinc-800 hover:bg-zinc-700";

    if (cell) {
      btn.classList.remove("hover:bg-zinc-700");
      if (cell.tile === "TempleFloor") {
        btn.classList.add("floor-tile");
      } else {
        const img = document.createElement("img");
        img.src = ROOM_ICONS[cell.tile];
        img.className = "w-full h-full object-contain";
        btn.appendChild(img);
      }
      if (cell.faded) btn.classList.add("faded");
      if (!isValidPlacement(i, cell.tile)) btn.classList.add("invalid");
    }

    btn.onclick = () => {
      if (selectedTile) {
        grid[i] = { tile: selectedTile, faded: planningMode };
        render();
      } else if (grid[i]) {
        grid[i].faded = !grid[i].faded;
        render();
      }
    };

    btn.oncontextmenu = e => {
      e.preventDefault();
      grid[i] = null;
      render();
    };

    gridEl.appendChild(btn);
  });

  /* Controls row */
  const controls = document.createElement("div");
  controls.className = "flex gap-4 items-center flex-wrap";

  const saveBtn = document.createElement("button");
  saveBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  saveBtn.textContent = "Save";
  saveBtn.onclick = saveLayout;

  const loadBtn = document.createElement("button");
  loadBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  loadBtn.textContent = "Load";
  loadBtn.onclick = loadLayout;

  const floorWrap = document.createElement("div");
  floorWrap.className = "flex items-center gap-2 text-sm";
  floorWrap.innerHTML = "<span>Floor tile:</span>";

  const floorBtn = document.createElement("button");
  floorBtn.className = `w-8 h-8 rounded floor-tile ${
    selectedTile === "TempleFloor" ? "ring-2 ring-emerald-500" : ""
  }`;
  floorBtn.onclick = () => {
    selectedTile = selectedTile === "TempleFloor" ? null : "TempleFloor";
    render();
  };

  floorWrap.appendChild(floorBtn);

  const planningLabel = document.createElement("label");
  planningLabel.className = "flex items-center gap-2 text-sm";
  const planningCheckbox = document.createElement("input");
  planningCheckbox.type = "checkbox";
  planningCheckbox.checked = planningMode;
  planningCheckbox.onchange = e => planningMode = e.target.checked;
  planningLabel.append(planningCheckbox, document.createTextNode("Planning mode"));

  controls.append(saveBtn, loadBtn, floorWrap, planningLabel);
  gridCol.append(gridEl, controls);

  /* Help section with instructions */
  const help = document.createElement("div");
  help.className = "text-sm text-zinc-300 max-w-md mt-4";
  help.innerHTML = `
    <strong>How to use:</strong>
    <ul class="list-disc ml-5 mt-1 space-y-1">
      <li>Select a room or floor tile, then left-click to place it.</li>
      <li>Click the same selector again to deselect.</li>
      <li>Planning mode places faded (planned) tiles.</li>
      <li>With no tile selected, click a tile to toggle planned â†” real.</li>
      <li>Right-click removes a tile.</li>
      <li>Only solid tiles count toward Active Bonuses.</li>
    </ul>
  `;
  gridCol.appendChild(help);

  /* ---------- ROOM COLUMN ---------- */
  const roomCol = document.createElement("div");
  roomCol.className = "min-w-72 w-72 space-y-2";
  roomCol.innerHTML = "<h2 class='font-semibold'>Room Tiles</h2>";

  Object.keys(ROOM_NAMES).forEach(r => {
    const btn = document.createElement("button");
    btn.className = `w-full flex items-center gap-2 px-3 py-2 rounded ${
      selectedTile === r ? "bg-emerald-600" : "bg-zinc-700"
    }`;
    const img = document.createElement("img");
    img.src = ROOM_ICONS[r];
    img.className = "w-5 h-5";
    btn.appendChild(img);
    btn.append(ROOM_NAMES[r]);
    btn.onclick = () => {
      selectedTile = selectedTile === r ? null : r;
      render();
    };
    roomCol.appendChild(btn);
  });

  /* ---------- ACTIVE BONUSES ---------- */
  const bonusCol = document.createElement("div");
  bonusCol.className = "w-[420px] space-y-2";
  bonusCol.innerHTML = `
    <h2 class="font-semibold">Active Bonuses</h2>
    <input id="search" class="w-full bg-zinc-800 p-2 rounded" placeholder="Search bonuses..." />
  `;

  const search = bonusCol.querySelector("#search");
  search.value = bonusFilter;
  search.oninput = e => {
    bonusFilter = e.target.value.toLowerCase();
    applyFilter();
  };

  const list = document.createElement("div");

  const counts = {};
  grid.forEach(c => {
    if (c && !c.faded && ROOM_NAMES[c.tile]) {
      counts[c.tile] = (counts[c.tile] || 0) + 1;
    }
  });

  const grouped = {};
  Object.entries(counts).forEach(([room, count]) => {
    formatBonuses(room, count).forEach(text => {
      const cat = categoryOf(text);
      grouped[cat] ??= [];
      grouped[cat].push(text);
    });
  });

  Object.entries(grouped).forEach(([cat, bonuses]) => {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-emerald-400";
    h.textContent = cat;
    list.appendChild(h);

    bonuses.forEach(text => {
      const li = document.createElement("div");
      li.className = "text-sm";
      li.textContent = text;
      list.appendChild(li);
    });
  });

  bonusCol.appendChild(list);

  container.append(gridCol, roomCol, bonusCol);
  app.appendChild(container);
}

render();
</script>
</body>
</html>
