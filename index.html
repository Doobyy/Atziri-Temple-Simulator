<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Temple Tile Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .tooltip {
      position: absolute;
      background: #18181b;
      border: 1px solid #3f3f46;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 50;
      pointer-events: none;
      white-space: nowrap;
    }
    .floor-tile {
      background-color: #372f21;
      box-shadow: inset 0 0 0 2px #98854d;
    }
    .faded {
      opacity: 0.6;
      filter: saturate(0.7);
    }
  </style>
</head>
<body class="bg-zinc-900 text-zinc-100">
<div id="app" class="p-6"></div>

<script>
const GRID_SIZE = 9;
let selectedTile = null;
let planningMode = false;
let bonusFilter = "";
let grid = Array(GRID_SIZE * GRID_SIZE).fill(null);

/* ---------------- ROOM DATA ---------------- */

const ROOM_NAMES = {
  Spymaster: "Spymaster",
  Garrison: "Garrison",
  LegionBarrack: "Legion Barracks",
  Commander: "Commander",
  FleshSurgeon: "Flesh Surgeon",
  Smithy: "Smithy",
  Armoury: "Armoury",
  SynthfleshLab: "Synthflesh Lab",
  TranscendentBarracks: "Transcendent Barracks",
  GolemWorks: "Golem Works",
  AlchemyLab: "Alchemy Lab",
  Thaumaturge: "Thaumaturge",
  CorruptionChamber: "Corruption Chamber",
  Generator: "Generator",
  SacrificialChamber: "Sacrificial Chamber",
  SealedVault: "Sealed Vault"
};

const ROOM_ICONS = {
  AlchemyLab: "icons/IconAlchemyLab.webp",
  Armoury: "icons/IconArmoury.webp",
  Commander: "icons/IconCommander.webp",
  CorruptionChamber: "icons/IconCorruption.webp",
  FleshSurgeon: "icons/IconFleshSurgeon.webp",
  Garrison: "icons/IconGarrison.webp",
  Generator: "icons/IconGenerator.webp",
  GolemWorks: "icons/IconGolemWorks.webp",
  SacrificialChamber: "icons/IconSacrificialChamber.webp",
  Smithy: "icons/IconSmithy.webp",
  SynthfleshLab: "icons/IconSynthflesh.webp",
  Thaumaturge: "icons/IconThaumaturge.webp",
  TranscendentBarracks: "icons/IconTranscendentBarracks.webp",
  SealedVault: "icons/IconVault.webp",
  LegionBarrack: "icons/IconViperLegionBarracks.webp",
  Spymaster: "icons/IconViperSpymaster.webp"
};

const ROOM_TILES = {
  Spymaster: { bonuses: ["MEDALLION:HIGH:LOCK"] },
  Garrison: { bonuses: ["20% Monster Packs", "30% Normal Monster Effectiveness"] },
  LegionBarrack: { bonuses: ["60% More Rare Monsters", "MEDALLION:HIGH:ADVANCED"] },
  Commander: { bonuses: ["60% Rare Monster Effectiveness", "MEDALLION:LOW:ADVANCED"] },
  FleshSurgeon: { bonuses: ["40% Unique Monster Effectiveness", "ITEM:Limb Modification"] },
  Smithy: { bonuses: ["60% Chest Item Rarity", "ITEM:Vaal Infuser"] },
  Armoury: { bonuses: ["60% Humanoid Monster Effectiveness"] },
  SynthfleshLab: { bonuses: ["40% Experience"] },
  TranscendentBarracks: { bonuses: ["60% More Magic Monsters"] },
  GolemWorks: { bonuses: ["ADD:High Priest", "MEDALLION:HIGH:ROOM"] },
  AlchemyLab: { bonuses: ["60% Item Rarity", "50% Gold", "ITEM:Core Destabiliser", "MEDALLION:LOW:ROOM"] },
  Thaumaturge: { bonuses: ["ADD:Quadrilla Sergeant", "ITEM:Crystallised Corruption", "MEDALLION:HIGH:ADVANCED"] },
  CorruptionChamber: { bonuses: ["60% Chance Rare Monster +1 Mod", "ADD:Royal Sentinel", "ITEM:Architect's Orb"] },
  Generator: { bonuses: ["60% Construct Monster Effectiveness", "ADD:Corrupted Abomination"] },
  SacrificialChamber: { bonuses: ["60% Increased Rare Chest", "ADD:Unchained Beast", "ITEM:Vaal Cultivation Orb", "MEDALLION:HIGH:ADVANCED"] },
  SealedVault: { bonuses: ["25% Item Rarity"] }
};

/* ---------------- BOOST RULES ---------------- */

const BOOST_RULES = {
  Spymaster: {
    amount: 0.30,
    targets: ["Garrison", "Commander", "Armoury", "Smithy", "LegionBarrack"]
  },
  Thaumaturge: {
    amount: 0.30,
    targets: ["CorruptionChamber", "SealedVault", "SacrificialChamber"]
  }
};

/* ---------------- HELPERS ---------------- */

function formatBonuses(tileKey, count = 1) {
  return ROOM_TILES[tileKey]?.bonuses.map(b => {
    if (b.startsWith("MEDALLION:")) {
      const [, chance, type] = b.split(":");
      return `+${count} ${chance === "HIGH" ? "High" : "Low"} Chance ${type} Medallion`;
    }
    if (b.startsWith("ITEM:")) return `+${count} ${b.slice(5)}`;
    if (b.startsWith("ADD:")) return `Adds ${count} ${b.slice(4)} to map`;
    const m = b.match(/(\d+)%\s*(.*)/);
    return `${Math.round(parseInt(m[1]) * count)}% ${m[2]}`;
  }) ?? [];
}

function categoryOf(text) {
  if (text.includes("Medallion")) return "Medallions";
  if (text.startsWith("+")) return "Items";
  if (text.startsWith("Adds")) return "Map Adds";
  if (text.includes("Monster")) return "Monster";
  return "Other";
}

/* ---------------- SAVE / LOAD ---------------- */

function saveLayout() {
  navigator.clipboard.writeText(JSON.stringify(grid));
  alert("Layout copied to clipboard");
}

function loadLayout() {
  const input = prompt("Paste layout data:");
  if (!input) return;
  try {
    const parsed = JSON.parse(input);
    if (Array.isArray(parsed)) {
      grid = parsed;
      render();
    }
  } catch {}
}

/* ---------------- RENDER ---------------- */

function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const container = document.createElement("div");
  container.className = "flex gap-6 items-start";

  /* ---------- GRID ---------- */

  const gridCol = document.createElement("div");
  gridCol.className = "space-y-3 shrink-0";

  const gridEl = document.createElement("div");
  gridEl.className = "grid grid-cols-9 gap-1";

  grid.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.className = "w-12 h-12 rounded-lg p-1 bg-zinc-800 hover:bg-zinc-700";

    if (cell) {
      btn.classList.remove("hover:bg-zinc-700");
      if (cell.tile === "TempleFloor") {
        btn.classList.add("floor-tile");
      } else {
        const img = document.createElement("img");
        img.src = ROOM_ICONS[cell.tile];
        img.className = "w-full h-full object-contain";
        btn.appendChild(img);
      }
      if (cell.faded) btn.classList.add("faded");
    }

    btn.onclick = () => {
      if (selectedTile) {
        grid[i] = { tile: selectedTile, faded: planningMode };
        render();
      } else if (grid[i]) {
        grid[i].faded = !grid[i].faded;
        render();
      }
    };

    btn.oncontextmenu = e => {
      e.preventDefault();
      grid[i] = null;
      render();
    };

    gridEl.appendChild(btn);
  });

  /* ---------- CONTROLS (FLOOR TILE RESTORED) ---------- */

  const controls = document.createElement("div");
  controls.className = "flex gap-4 items-center flex-wrap";

  const saveBtn = document.createElement("button");
  saveBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  saveBtn.textContent = "Save";
  saveBtn.onclick = saveLayout;

  const loadBtn = document.createElement("button");
  loadBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  loadBtn.textContent = "Load";
  loadBtn.onclick = loadLayout;

  const floorWrap = document.createElement("div");
  floorWrap.className = "flex items-center gap-2 text-sm";
  floorWrap.innerHTML = "<span>Floor tile:</span>";

  const floorBtn = document.createElement("button");
  floorBtn.className = `w-8 h-8 rounded floor-tile ${
    selectedTile === "TempleFloor" ? "ring-2 ring-emerald-500" : ""
  }`;
  floorBtn.onclick = () => {
    selectedTile = selectedTile === "TempleFloor" ? null : "TempleFloor";
    render();
  };

  floorWrap.appendChild(floorBtn);

  const planningLabel = document.createElement("label");
  planningLabel.className = "flex items-center gap-2 text-sm";
  const planningCheckbox = document.createElement("input");
  planningCheckbox.type = "checkbox";
  planningCheckbox.checked = planningMode;
  planningCheckbox.onchange = e => planningMode = e.target.checked;
  planningLabel.append(planningCheckbox, document.createTextNode("Planning mode"));

  controls.append(saveBtn, loadBtn, floorWrap, planningLabel);
  gridCol.append(gridEl, controls);

  /* ---------- ROOM LIST ---------- */

  const roomCol = document.createElement("div");
  roomCol.className = "min-w-72 w-72 space-y-2";
  roomCol.innerHTML = "<h2 class='font-semibold'>Room Tiles</h2>";

  Object.keys(ROOM_TILES).forEach(r => {
    const btn = document.createElement("button");
    btn.className = `w-full flex items-center gap-2 px-3 py-2 rounded ${
      selectedTile === r ? "bg-emerald-600" : "bg-zinc-700"
    }`;
    const img = document.createElement("img");
    img.src = ROOM_ICONS[r];
    img.className = "w-5 h-5";
    btn.appendChild(img);
    btn.append(ROOM_NAMES[r]);
    btn.onclick = () => {
      selectedTile = selectedTile === r ? null : r;
      render();
    };
    roomCol.appendChild(btn);
  });

  /* ---------- ACTIVE BONUSES ---------- */

  const bonusCol = document.createElement("div");
  bonusCol.className = "w-[420px] space-y-2";
  bonusCol.innerHTML = `<h2 class="font-semibold">Active Bonuses</h2>`;

  const list = document.createElement("div");

  const counts = {};
  const boosters = {};
  const boostReport = [];

  grid.forEach(c => {
    if (!c || c.faded) return;
    if (ROOM_TILES[c.tile]) counts[c.tile] = (counts[c.tile] || 0) + 1;
    if (BOOST_RULES[c.tile]) boosters[c.tile] = (boosters[c.tile] || 0) + 1;
  });

  const grouped = {};

  Object.entries(counts).forEach(([room, base]) => {
    let mult = 1;
    Object.entries(boosters).forEach(([b, n]) => {
      const rule = BOOST_RULES[b];
      if (rule.targets.includes(room)) mult += rule.amount * n;
    });

    if (mult > 1) {
      boostReport.push(`${ROOM_NAMES[room]}: +${Math.round((mult - 1) * 100)}% (included)`);
    }

    formatBonuses(room, base * mult).forEach(text => {
      const cat = categoryOf(text);
      grouped[cat] ??= [];
      grouped[cat].push(text);
    });
  });

  Object.entries(grouped).forEach(([cat, bonuses]) => {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-emerald-400";
    h.textContent = cat;
    list.appendChild(h);
    bonuses.forEach(text => {
      const d = document.createElement("div");
      d.className = "text-sm";
      d.textContent = text;
      list.appendChild(d);
    });
  });

  if (boostReport.length) {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-sky-400";
    h.textContent = "Boosted Effects (Already Included)";
    list.appendChild(h);
    boostReport.forEach(t => {
      const d = document.createElement("div");
      d.className = "text-sm opacity-80";
      d.textContent = t;
      list.appendChild(d);
    });
  }

  bonusCol.appendChild(list);

  container.append(gridCol, roomCol, bonusCol);
  app.appendChild(container);
}

render();
</script>
</body>
</html>
