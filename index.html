<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Temple Tile Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .tooltip {
      position: absolute;
      background: #18181b;
      border: 1px solid #3f3f46;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 50;
      pointer-events: none;
      white-space: nowrap;
    }
    .floor-tile {
      background-color: #372f21;
      box-shadow: inset 0 0 0 2px #98854d;
    }
    .faded {
      opacity: 0.6;
      filter: saturate(0.7);
    }
  </style>
</head>
<body class="bg-zinc-900 text-zinc-100">
<div id="app" class="p-6"></div>

<script>
// Initial setup, no rules added yet
const GRID_SIZE = 9;
let selectedTile = null;
let planningMode = false;
let bonusFilter = "";
let grid = Array(GRID_SIZE * GRID_SIZE).fill(null);

// Room names for display
const ROOM_NAMES = {
  Spymaster: "Spymaster",
  Garrison: "Garrison",
  LegionBarrack: "Legion Barracks",
  Commander: "Commander",
  FleshSurgeon: "Flesh Surgeon",
  Smithy: "Smithy",
  Armoury: "Armoury",
  SynthfleshLab: "Synthflesh Lab",
  TranscendentBarracks: "Transcendent Barracks",
  GolemWorks: "Golem Works",
  AlchemyLab: "Alchemy Lab",
  Thaumaturge: "Thaumaturge",
  CorruptionChamber: "Corruption Chamber",
  Generator: "Generator",
  SacrificialChamber: "Sacrificial Chamber",
  SealedVault: "Sealed Vault"
};

// Room Icons for visual representation
const ROOM_ICONS = {
  AlchemyLab: "icons/IconAlchemyLab.webp",
  Armoury: "icons/IconArmoury.webp",
  Commander: "icons/IconCommander.webp",
  CorruptionChamber: "icons/IconCorruption.webp",
  FleshSurgeon: "icons/IconFleshSurgeon.webp",
  Garrison: "icons/IconGarrison.webp",
  Generator: "icons/IconGenerator.webp",
  GolemWorks: "icons/IconGolemWorks.webp",
  SacrificialChamber: "icons/IconSacrificialChamber.webp",
  Smithy: "icons/IconSmithy.webp",
  SynthfleshLab: "icons/IconSynthflesh.webp",
  Thaumaturge: "icons/IconThaumaturge.webp",
  TranscendentBarracks: "icons/IconTranscendentBarracks.webp",
  SealedVault: "icons/IconVault.webp",
  LegionBarrack: "icons/IconViperLegionBarracks.webp",
  Spymaster: "icons/IconViperSpymaster.webp"
};

// Room bonuses and effects
const ROOM_TILES = {
  Spymaster: { bonuses: ["30% Effect of Temple Mods", "MEDALLION:HIGH:LOCK"] },
  Garrison: { bonuses: ["20% Monster Packs", "30% Normal Monster Effectiveness"] },
  LegionBarrack: { bonuses: ["60% More Rare Monsters", "MEDALLION:HIGH:ADVANCED"] },
  Commander: { bonuses: ["60% Rare Monster Effectiveness", "MEDALLION:LOW:ADVANCED"] },
  FleshSurgeon: { bonuses: ["40% Unique Monster Effectiveness", "ITEM:Limb Modification"] },
  Smithy: { bonuses: ["60% Chest Item Rarity", "ITEM:Vaal Infuser"] },
  Armoury: { bonuses: ["60% Humanoid Monster Effectiveness"] },
  SynthfleshLab: { bonuses: ["40% Experience"] },
  TranscendentBarracks: { bonuses: ["60% More Magic Monsters"] },
  GolemWorks: { bonuses: ["30% Effect of Temple Mods", "ADD:High Priest", "MEDALLION:HIGH:ROOM"] },
  AlchemyLab: { bonuses: ["60% Item Rarity", "50% Gold", "ITEM:Core Destabiliser", "MEDALLION:LOW:ROOM"] },
  Thaumaturge: { bonuses: ["30% Effect of Temple Mods", "ADD:Quadrilla Sergeant", "ITEM:Crystallised Corruption", "MEDALLION:HIGH:ADVANCED"] },
  CorruptionChamber: { bonuses: ["60% Chance Rare Monster +1 Mod", "ADD:Royal Sentinel", "ITEM:Architect's Orb"] },
  Generator: { bonuses: ["60% Construct Monster Effectiveness", "ADD:Corrupted Abomination"] },
  SacrificialChamber: { bonuses: ["60% Increased Rare Chest", "ADD:Unchained Beast", "ITEM:Vaal Cultivation Orb", "MEDALLION:HIGH:ADVANCED"] },
  SealedVault: { bonuses: ["25% Item Rarity"] }
};

// Helper to format bonus text
function formatBonuses(tileKey, count = 1) {
  return ROOM_TILES[tileKey]?.bonuses.map(b => {
    if (b.startsWith("MEDALLION:")) {
      const [, chance, type] = b.split(":");
      return `+${count} ${chance === "HIGH" ? "High" : "Low"} Chance ${type} Medallion`;
    }
    if (b.startsWith("ITEM:")) return `+${count} ${b.slice(5)}`;
    if (b.startsWith("ADD:")) return `Adds ${count} ${b.slice(4)} to map`;
    const m = b.match(/(\d+)%\s*(.*)/);
    return `${parseInt(m[1]) * count}% ${m[2]}`;
  }) ?? [];
}

// Category of bonus
function categoryOf(text) {
  if (text.includes("Medallion")) return "Medallions";
  if (text.startsWith("+")) return "Items";
  if (text.startsWith("Adds")) return "Map Adds";
  if (text.includes("Monster")) return "Monster";
  return "Other";
}

// Function to apply search filter to bonuses
function applyFilter() {
  document.querySelectorAll(".text-sm").forEach(el => {
    const match = !bonusFilter || el.textContent.toLowerCase().includes(bonusFilter);
    el.classList.toggle("opacity-30", !match);
  });
}

// Save and Load layout functions
function saveLayout() {
  navigator.clipboard.writeText(JSON.stringify(grid));
  alert("Layout copied to clipboard");
}

function loadLayout() {
  const input = prompt("Paste layout data:");
  if (!input) return;
  try {
    const parsed = JSON.parse(input);
    if (Array.isArray(parsed)) {
      grid = parsed;
      render();
    }
  } catch {}
}

// Render the layout with tile selectors and active bonuses
function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const container = document.createElement("div");
  container.className = "flex gap-6 items-start";

  /* ---------- GRID COLUMN ---------- */
  const gridCol = document.createElement("div");
  gridCol.className = "space-y-3 shrink-0";

  const gridEl = document.createElement("div");
  gridEl.className = "grid grid-cols-9 gap-1";

  grid.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.className = "w-12 h-12 rounded-lg p-1 bg-zinc-800 hover:bg-zinc-700";

    if (cell) {
      btn.classList.remove("hover:bg-zinc-700");
      if (cell.tile === "TempleFloor") {
        btn.classList.add("floor-tile");
      } else {
        const img = document.createElement("img");
        img.src = ROOM_ICONS[cell.tile];
        img.className = "w-full h-full object-contain";
        btn.appendChild(img);
      }
      if (cell.faded) btn.classList.add("faded");
    }

    btn.onclick = () => {
      if (selectedTile) {
        grid[i] = { tile: selectedTile, faded: planningMode };
        render();
      } else if (grid[i]) {
        grid[i].faded = !grid[i].faded;
        render();
      }
    };

    btn.oncontextmenu = e => {
      e.preventDefault();
      grid[i] = null;
      render();
    };

    gridEl.appendChild(btn);
  });

  const controls = document.createElement("div");
  controls.className = "flex gap-4 items-center flex-wrap";

  const saveBtn = document.createElement("button");
  saveBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  saveBtn.textContent = "Save";
  saveBtn.onclick = saveLayout;

  const loadBtn = document.createElement("button");
  loadBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  loadBtn.textContent = "Load";
  loadBtn.onclick = loadLayout;

  const floorWrap = document.createElement("div");
  floorWrap.className = "flex items-center gap-2 text-sm";
  floorWrap.innerHTML = "<span>Floor tile:</span>";

  const floorBtn = document.createElement("button");
  floorBtn.className = `w-8 h-8 rounded floor-tile ${
    selectedTile === "TempleFloor" ? "ring-2 ring-emerald-500" : ""
  }`;
  floorBtn.onclick = () => {
    selectedTile = selectedTile === "TempleFloor" ? null : "TempleFloor";
    render();
  };

  floorWrap.appendChild(floorBtn);

  const planningLabel = document.createElement("label");
  planningLabel.className = "flex items-center gap-2 text-sm";
  const planningCheckbox = document.createElement("input");
  planningCheckbox.type = "checkbox";
  planningCheckbox.checked = planningMode;
  planningCheckbox.onchange = e => planningMode = e.target.checked;
  planningLabel.append(planningCheckbox, document.createTextNode("Planning mode"));

  controls.append(saveBtn, loadBtn, floorWrap, planningLabel);
  gridCol.append(gridEl, controls);

  /* Help section with instructions */
  const help = document.createElement("div");
  help.className = "text-sm text-zinc-300 max-w-md mt-4";
  help.innerHTML = `
    <strong>How to use:</strong>
    <ul class="list-disc ml-5 mt-1 space-y-1">
      <li>Select a room or floor tile, then left-click to place it.</li>
      <li>Click the same selector again to deselect.</li>
      <li>Planning mode places faded (planned) tiles.</li>
      <li>With no tile selected, click a tile to toggle planned â†” real.</li>
      <li>Right-click removes a tile.</li>
      <li>Only solid tiles count toward Active Bonuses.</li>
    </ul>
  `;
  gridCol.appendChild(help);

  /* ---------- ROOM COLUMN ---------- */
  const roomCol = document.createElement("div");
  roomCol.className = "min-w-72 w-72 space-y-2";
  roomCol.innerHTML = "<h2 class='font-semibold'>Room Tiles</h2>";

  Object.keys(ROOM_TILES).forEach(r => {
    const btn = document.createElement("button");
    btn.className = `w-full flex items-center gap-2 px-3 py-2 rounded ${
      selectedTile === r ? "bg-emerald-600" : "bg-zinc-700"
    }`;
    const img = document.createElement("img");
    img.src = ROOM_ICONS[r];
    img.className = "w-5 h-5";
    btn.appendChild(img);
    btn.append(ROOM_NAMES[r]);
    btn.onclick = () => {
      selectedTile = selectedTile === r ? null : r;
      render();
    };
    roomCol.appendChild(btn);
  });

  /* ---------- ACTIVE BONUSES ---------- */
  const bonusCol = document.createElement("div");
  bonusCol.className = "w-[420px] space-y-2";
  bonusCol.innerHTML = `
    <h2 class="font-semibold">Active Bonuses</h2>
    <input id="search" class="w-full bg-zinc-800 p-2 rounded" placeholder="Search bonuses..." />
  `;

  const search = bonusCol.querySelector("#search");
  search.value = bonusFilter;
  search.oninput = e => {
    bonusFilter = e.target.value.toLowerCase();
    applyFilter();
  };

  const list = document.createElement("div");

  const counts = {};
  grid.forEach(c => {
    if (c && !c.faded && ROOM_TILES[c.tile]) {
      counts[c.tile] = (counts[c.tile] || 0) + 1;
    }
  });

  const grouped = {};
  Object.entries(counts).forEach(([room, count]) => {
    formatBonuses(room, count).forEach(text => {
      const cat = categoryOf(text);
      grouped[cat] ??= [];
      grouped[cat].push(text);
    });
  });

  Object.entries(grouped).forEach(([cat, bonuses]) => {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-emerald-400";
    h.textContent = cat;
    list.appendChild(h);

    bonuses.forEach(text => {
      const li = document.createElement("div");
      li.className = "text-sm";
      li.textContent = text;
      list.appendChild(li);
    });
  });

  bonusCol.appendChild(list);

  container.append(gridCol, roomCol, bonusCol);
  app.appendChild(container);
}

render();
</script>
</body>
</html>
 
